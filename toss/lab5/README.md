# Rust Web 服务器实现

20232241392-文浩然-软2305

https://github.com/saurlax/dlut-homework/tree/main/toss/lab5

## 介绍

本报告记录了作为实验 5 的一部分，使用 Rust 实现的简单 HTTP Web 服务器。该项目通过使用三种不同的方法实现相同的功能，探索了服务器开发中的不同并发模型：单线程、多线程和使用 Tokio 的异步 I/O。此外，还开发了一个基准测试系统来比较这些实现的性能。

## Web 服务器概念

Web 服务器是一种响应客户端（通常是 Web 浏览器）HTTP 请求并提供内容（如 HTML 页面、图像或其他 Web 资源）的软件应用。Web 服务器的基本流程包括：

1. 在特定端口上监听传入连接（通常为 HTTP 的 80 端口或 HTTPS 的 443 端口）
2. 接受客户端连接
3. 解析 HTTP 请求
4. 处理请求并生成适当的响应
5. 将响应发送回客户端
6. 根据需要关闭连接或保持连接活动

Web 服务器可以使用各种模型处理并发连接，这是本实验的主要关注点。

## 实现概述

该项目实现了一个基本的 HTTP 服务器，可以：
- 在指定的主机和端口上监听
- 解析 HTTP 请求
- 为特定路由提供 HTML 内容
- 处理 GET 请求
- 返回适当的 HTTP 状态码（200 OK、404 Not Found、405 Method Not Allowed）

### 项目结构

代码库组织为以下模块：

- `main.rs`：入口点、命令行参数解析和基准测试逻辑
- `utils.rs`：HTTP 请求解析和响应构建的通用工具
- `single_thread.rs`：单线程服务器实现
- `multi_thread.rs`：带线程池的多线程服务器实现
- `async_tokio.rs`：使用 Tokio 的异步 I/O 实现

### 已实现的并发模型

#### 1. 单线程实现

单线程实现按顺序处理客户端连接。它使用非阻塞 I/O 来检查关闭信号，同时继续处理传入的连接。这种方法很简单，但一次只能处理一个请求，这在高负载下会成为瓶颈。

#### 2. 多线程实现

多线程版本使用线程池模式来处理多个并发连接。当接受新连接时，会将其委托给线程池中的工作线程。这允许服务器同时处理多个请求，有效利用多个 CPU 核心。实现包括：

- 自定义 `ThreadPool` 实现
- 从共享通道拉取任务的工作线程
- 使用 Mutex 和 Arc 进行线程同步

#### 3. 异步 I/O 实现

异步实现使用 Tokio，一个流行的 Rust 异步运行时。这种方法允许使用少量线程处理许多并发连接，通过使用非阻塞 I/O 操作和任务调度。主要特点包括：

- Tokio 运行时管理异步任务
- 异步/等待语法使异步代码更易读
- 任务生成以同时处理连接
- 高效的 I/O 操作，无需阻塞线程

## 性能比较

实现了一个基准测试系统来比较三种服务器实现的性能。基准测试：

1. 启动指定类型的服务器
2. 创建多个并发发送 HTTP 请求的客户端线程
3. 测量处理固定数量请求所需的时间
4. 停止服务器并报告性能指标

每种实现都在不同的并发级别下进行测试，以了解它们在不同负载下的行为。基准测试工具支持配置：
- 并发客户端数量
- 每个客户端的请求数
- 总请求数

## 使用方法

可以使用命令行参数以不同的配置运行服务器：

```
cargo run -- -t <server_type> -H <host> -p <port>
```

其中：
- `<server_type>` 可以是 "single"、"multi"、"async" 或 "bench"
- `<host>` 是要监听的主机地址（默认："localhost"）
- `<port>` 是要监听的端口（默认：7878）

例如，运行多线程版本：
```
cargo run -- -t multi
```

运行性能基准测试：
```
cargo run -- -t bench
```

## 结论

该项目演示了如何在 Rust 中实现不同的并发模型来创建具有不同性能特征的 Web 服务器。基准测试结果显示了不同方法之间的权衡：

- 单线程实现最简单，但吞吐量有限。
- 多线程实现可以利用多个 CPU 核心，但线程管理有开销。
- 异步实现可以以低资源使用率高效处理许多并发连接。

每种方法都有其用例，选择取决于应用程序的特定需求、预期负载和可用系统资源。
